//
// Created by Brett on 2024-03-15.
//
#include "PerlinNoise.h"

namespace {
// source http://riven8192.blogspot.com/2010/08/calculate-perlinnoise-twice-as-fast.html
    inline double gradient3(int hash, double x, double y, double z) {
    // Original examines the lower 4 bits of the hash to determine which gradient3 vec to return.
    //    int h = hash & 15;
    //    double u = h < 8 ? x : y;
    //    double v = h <4 ? y : h == 12 || h == 14 ? x : z;
    //    return (( h &1) == 0 ? u : -u ) + (( h &2) == 0 ? v : -v );

        // source http://riven8192.blogspot.com/2010/08/calculate-perlinnoise-twice-as-fast.html
        // Essentially this exploits the possible combinations as a precomputed case statement lookup.
        switch (hash & 0x0F) {
            case 0x0: return  x + y;
            case 0x1: return -x + y;
            case 0x2: return  x - y;
            case 0x3: return -x - y;
            case 0x4: return  x + z;
            case 0x5: return -x + z;
            case 0x6: return  x - z;
            case 0x7: return -x - z;
            case 0x8: return  y + z;
            case 0x9: return -y + z;
            case 0xA: return  y - z;
            case 0xB: return -y - z;
            case 0xC: return  y + x;
            case 0xD: return -y + z;
            case 0xE: return  y - x;
            case 0xF: return -y - z;
        }

        // I was curious (without profiling) if predication could make it faster, turns out its significantly slower
        // so theres very little branch misprediction
//        int c = hash & 0x0F;
//        return (c == 0x0)   * ( x + y)
//            + (c == 0x1)    * (-x + y)
//            + (c == 0x2)    * ( x - y)
//            + (c == 0x3)    * (-x - y)
//            + (c == 0x4)    * ( x + z)
//            + (c == 0x6)    * (-x + z)
//            + (c == 0x7)    * ( x - z)
//            + (c == 0x8)    * (-x - z)
//            + (c == 0x9)    * ( y + z)
//            + (c == 0xA)    * (-y + z)
//            + (c == 0xB)    * ( y - z)
//            + (c == 0xC)    * (-y - z)
//            + (c == 0xD)    * ( y + x)
//            + (c == 0xE)    * (-y + z)
//            + (c == 0xF)    * ( y - x);
    }

    // source http://riven8192.blogspot.com/2010/08/calculate-perlinnoise-twice-as-fast.html
    inline double gradient2(int hash, double x, double y) {
        // Original examines the lower 4 bits of the hash to determine which gradient3 vec to return.
        //    int h = hash & 15;
        //    double u = h < 8 ? x : y;
        //    double v = h <4 ? y : h == 12 || h == 14 ? x : z;
        //    return (( h &1) == 0 ? u : -u ) + (( h &2) == 0 ? v : -v );

        // source http://riven8192.blogspot.com/2010/08/calculate-perlinnoise-twice-as-fast.html
        // Essentially this exploits the possible combinations as a precomputed case statement lookup.
        switch (hash & 0x03) {
            case 0x0: return  x + y;
            case 0x1: return -x + y;
            case 0x2: return  x - y;
            case 0x3: return -x - y;
        }
    }
}


KGV::Procedural::PerlinNoise::PerlinNoise() {
    for (int i = 0; i < 256; ++i) {
        p[256 + i] = p[i] = permutation[i];
    }
}

double KGV::Procedural::PerlinNoise::lerp(double x, double y, double t) {
    return x + t * (y - x);
}


double KGV::Procedural::PerlinNoise::noiseDP(double x, double y, double z) {
    // find the hyper cube that contains our point.
    // We're purposefully using floating point truncation as our floor() method.
    int iX      = static_cast<int>(x) & 255;
    int iY      = static_cast<int>(y) & 255;
    int iZ      = static_cast<int>(z) & 255;
    x           = x - static_cast<int>(x);
    y           = y - static_cast<int>(y);
    z           = z - static_cast<int>(z);
    double u    = fade(x);
    double v    = fade(y);
    double w    = fade(z);

    // Create a hash for each vertex of the hyper cube.
    int aaa, aba, aab, abb, baa, bba, bab, bbb;
    aaa = p[p[p[    iX  ]+      iY ] +  iZ ];
    aba = p[p[p[    iX  ]+      iY + 1]+  iZ ];
    aab = p[p[p[    iX  ]+      iY ] +  iZ + 1];
    abb = p[p[p[    iX  ]+      iY + 1]+  iZ + 1];
    baa = p[p[p[    iX + 1]+      iY ] +  iZ ];
    bba = p[p[p[    iX + 1]+      iY + 1]+  iZ ];
    bab = p[p[p[    iX + 1]+      iY ] +  iZ + 1];
    bbb = p[p[p[    iX + 1]+      iY + 1]+  iZ + 1];

    // blend the results together using linear interpolation but with the curves generated by the fad function.
    // Probably could use SIMD like in the F32 version but thats for a later time.
    double  x1 = lerp(gradient3(aaa, x, y, z),
                      gradient3(baa, x - 1, y, z),
                  u);
    double  x2 = lerp(gradient3(aba, x, y - 1, z),
                      gradient3(bba, x - 1, y - 1, z),
                  u);
    double  y1 = lerp(x1, x2, v);
    
            x1 = lerp(gradient3(aab, x, y, z - 1),
                      gradient3(bab, x - 1, y, z - 1),
                      u);
            x2 = lerp(gradient3(abb, x, y - 1, z - 1),
                      gradient3(bbb, x - 1, y - 1, z - 1),
                      u);
    double  y2 = lerp (x1, x2, v);

    return  lerp (y1, y2, w);
}

double KGV::Procedural::PerlinNoise::noiseDP(double x, double y) {
    // find the hyper cube that contains our point.
    // We're purposefully using floating point truncation as our floor() method.
    int iX      = static_cast<int>(x) & 255;
    int iY      = static_cast<int>(y) & 255;
    x           = x - static_cast<int>(x);
    y           = y - static_cast<int>(y);
    double u    = fade(x);
    double v    = fade(y);

    // Create a hash for each vertex of the hyper cube.
    int aa, ab, ba, bb;
    aa = p[p[    iX    ]+      iY      ];
    ab = p[p[    iX    ]+      iY + 1  ];
    ba = p[p[    iX + 1]+      iY      ];
    bb = p[p[    iX + 1]+      iY + 1  ];

    // blend the results together using linear interpolation but with the curves generated by the fad function.
    // Probably could use SIMD like in the F32 version but thats for a later time.
    double  x1 = lerp(gradient2(aa, x, y),
                      gradient2(ba, x - 1, y),
                          u);
    double  x2 = lerp(gradient2(ab, x, y - 1),
                      gradient2(bb, x - 1, y - 1),
                          u);

    return  lerp (x1, x2, v);
}


double KGV::Procedural::PerlinNoise::fade(double t) {
    // This is the same function as defined by Ken Perlin.
    // Ken perlins orginal formula is "6t^5 - 15t^4 + 10^t3" simplified and more performant below.
    return t * t * t * (t * (t * 6 - 15) + 10);
}

float KGV::Procedural::PerlinNoise::noiseSP(double x, double y, double z) {
    // find the hyper cube that contains our point.
    // We're purposefully using floating point truncation as our floor() method.
    int iX      = static_cast<int>(x) & 255;
    int iY      = static_cast<int>(y) & 255;
    int iZ      = static_cast<int>(y) & 255;
    x           = x - static_cast<int>(x);
    y           = y - static_cast<int>(y);
    z           = z - static_cast<int>(z);
    double u    = fade(x);
    double v    = fade(y);
    double w    = fade(z);

    // Create a hash for each vertex of the hyper cube.
    int aaa, aba, aab, abb, baa, bba, bab, bbb;
    aaa = p[p[p[    iX  ]+      iY ] +  iZ ];
    aba = p[p[p[    iX  ]+      iY++]+  iZ ];
    aab = p[p[p[    iX  ]+      iY ] +  iZ++];
    abb = p[p[p[    iX  ]+      iY++]+  iZ++];
    baa = p[p[p[    iX++]+      iY ] +  iZ ];
    bba = p[p[p[    iX++]+      iY++]+  iZ ];
    bab = p[p[p[    iX++]+      iY ] +  iZ++];
    bbb = p[p[p[    iX++]+      iY++]+  iZ++];

    // blend the results together using linear interpolation but with the curves generated by the fad function.
    DirectX::XMVECTOR x1 = {
        static_cast<float>(gradient3(aaa, x, y, z)),
        static_cast<float>(gradient3(aba, x, y - 1, z)),
        static_cast<float>(gradient3(aab, x, y, z - 1)),
        static_cast<float>(gradient3(abb, x, y - 1, z - 1))
    };

    DirectX::XMVECTOR x2 = {
        static_cast<float>(gradient3(baa, x - 1, y, z)),
        static_cast<float>(gradient3(bba, x - 1, y - 1, z)),
        static_cast<float>(gradient3(bab, x - 1, y, z - 1)),
        static_cast<float>(gradient3(bbb, x - 1, y - 1, z - 1))
    };

    DirectX::XMFLOAT4 res;
    DirectX::XMStoreFloat4(&res, DirectX::XMVectorLerp(x1, x2, u));
    auto y1 = lerp(res.x, res.y, v);
    auto y2 = lerp(res.z, res.w, v);
    return (lerp(y1, y2, w) + 1) / 2;
}


