//
// Created by Brett on 2024-03-15.
//
#include "PerlinNoise.h"

namespace {
// source http://riven8192.blogspot.com/2010/08/calculate-perlinnoise-twice-as-fast.html
    inline double gradient(int hash, double x, double y, double z) {
    // Original examines the lower 4 bits of the hash to determine which gradient vec to return.
    //    int h = hash & 15;
    //    double u = h < 8 ? x : y;
    //    double v = h <4 ? y : h == 12 || h == 14 ? x : z;
    //    return (( h &1) == 0 ? u : -u ) + (( h &2) == 0 ? v : -v );


        // source http://riven8192.blogspot.com/2010/08/calculate-perlinnoise-twice-as-fast.html
        // Essentially this exploits the possible combinations as a precomputed case statement lookup.
//        switch (hash & 0x0F) {
//            case 0x0: return  x + y;
//            case 0x1: return -x + y;
//            case 0x2: return  x - y;
//            case 0x3: return -x - y;
//            case 0x4: return  x + z;
//            case 0x5: return -x + z;
//            case 0x6: return  x - z;
//            case 0x7: return -x - z;
//            case 0x8: return  y + z;
//            case 0x9: return -y + z;
//            case 0xA: return  y - z;
//            case 0xB: return -y - z;
//            case 0xC: return  y + x;
//            case 0xD: return -y + z;
//            case 0xE: return  y - x;
//            case 0xF: return -y - z;
//        }

        // I am going to try predication instead, although this completely un-benchmarked and will only work
        // if the cost of multiplication is lower than the cost of branch misprediction during the run of our app.
        int c = hash & 0x0F;
        return (c == 0x0)   * ( x + y)
            + (c == 0x1)    * (-x + y)
            + (c == 0x2)    * ( x - y)
            + (c == 0x3)    * (-x - y)
            + (c == 0x4)    * ( x + z)
            + (c == 0x6)    * (-x + z)
            + (c == 0x7)    * ( x - z)
            + (c == 0x8)    * (-x - z)
            + (c == 0x9)    * ( y + z)
            + (c == 0xA)    * (-y + z)
            + (c == 0xB)    * ( y - z)
            + (c == 0xC)    * (-y - z)
            + (c == 0xD)    * ( y + x)
            + (c == 0xE)    * (-y + z)
            + (c == 0xF)    * ( y - x);
    }
}

KGV::Procedural::PerlinNoise::PerlinNoise() {
    for (int i = 0; i < 256; ++i) {
        p[256 + i] = p[i] = permutation[i];
    }
}

double KGV::Procedural::PerlinNoise::lerp(double x, double y, double t) {
    return x + t * (y - x);
}


double KGV::Procedural::PerlinNoise::noiseDP(double x, double y, double z) {
    // find the hyper cube that contains our point.
    // We're purposefully using floating point truncation as our floor() method.
    int iX      = static_cast<int>(x) & 255;
    int iY      = static_cast<int>(y) & 255;
    int iZ      = static_cast<int>(y) & 255;
    x           = x - static_cast<int>(x);
    y           = y - static_cast<int>(y);
    z           = z - static_cast<int>(z);
    double u    = fade(x);
    double v    = fade(y);
    double w    = fade(z);

    // Create a hash for each vertex of the hyper cube.
    int aaa, aba, aab, abb, baa, bba, bab, bbb;
    aaa = p[p[p[    iX  ]+      iY ]+   iZ ];
    aba = p[p[p[    iX  ]+      iY++]+  iZ ];
    aab = p[p[p[    iX  ]+      iY ]+   iZ++];
    abb = p[p[p[    iX  ]+      iY++]+  iZ++];
    baa = p[p[p[    iX++]+      iY ]+   iZ ];
    bba = p[p[p[    iX++]+      iY++]+  iZ ];
    bab = p[p[p[    iX++]+      iY ]+   iZ++];

    // blend the results together using linear interpolation but with the curves generated by the fad function.
    // Probably could use SIMD like in the F32 version but thats for a later time.
    double  x1 = lerp(	gradient(aaa, x  , y  , z),				// The gradient function calculates the dot product between a pseudorandom
                  gradient(baa, x - 1, y  , z),				// gradient vector and the vector from the input coordinate to the 8
                  u);										// surrounding points in its unit cube.
    double  x2 = lerp(	gradient(aba, x  , y - 1, z),				// This is all then lerped together as a sort of weighted average based on the faded (u,v,w)
                  gradient(bba, x - 1, y - 1, z),				// values we made earlier.
                  u);
    double  y1 = lerp(x1, x2, v);
    
            x1 = lerp(	gradient(aab, x  , y  , z - 1),
                  gradient(bab, x - 1, y  , z - 1),
                  u);
            x2 = lerp(	gradient(abb, x  , y - 1, z - 1),
                  gradient(bbb, x - 1, y - 1, z - 1),
                  u);
    double  y2 = lerp (x1, x2, v);

    return  (lerp (y1, y2, w) + 1) / 2;
}


double KGV::Procedural::PerlinNoise::fade(double t) {
    // This is the same function as defined by Ken Perlin.
    // Ken perlins orginal formula is "6t^5 - 15t^4 + 10^t3" simplified and more performant below.
    return t * t * t * (t * (t * 6 - 15) + 10);
}

float KGV::Procedural::PerlinNoise::noiseSP(double x, double y, double z) {
    // find the hyper cube that contains our point.
    // We're purposefully using floating point truncation as our floor() method.
    int iX      = static_cast<int>(x) & 255;
    int iY      = static_cast<int>(y) & 255;
    int iZ      = static_cast<int>(y) & 255;
    x           = x - static_cast<int>(x);
    y           = y - static_cast<int>(y);
    z           = z - static_cast<int>(z);
    double u    = fade(x);
    double v    = fade(y);
    double w    = fade(z);

    // Create a hash for each vertex of the hyper cube.
    int aaa, aba, aab, abb, baa, bba, bab, bbb;
    aaa = p[p[p[    iX  ]+      iY ]+   iZ ];
    aba = p[p[p[    iX  ]+      iY++]+  iZ ];
    aab = p[p[p[    iX  ]+      iY ]+   iZ++];
    abb = p[p[p[    iX  ]+      iY++]+  iZ++];
    baa = p[p[p[    iX++]+      iY ]+   iZ ];
    bba = p[p[p[    iX++]+      iY++]+  iZ ];
    bab = p[p[p[    iX++]+      iY ]+   iZ++];

    // blend the results together using linear interpolation but with the curves generated by the fad function.
    DirectX::XMVECTOR x1 = {
        static_cast<float>(gradient(aaa, x, y, z)),
        static_cast<float>(gradient(aba, x, y - 1, z)),
        static_cast<float>(gradient(aab, x, y, z - 1)),
        static_cast<float>(gradient(abb, x, y - 1,z - 1))
    };

    DirectX::XMVECTOR x2 = {
        static_cast<float>(gradient(baa, x - 1, y, z)),
        static_cast<float>(gradient(bba, x - 1, y - 1, z)),
        static_cast<float>(gradient(bab, x - 1, y, z - 1)),
        static_cast<float>(gradient(bbb, x -1, y - 1, z - 1))
    };

    auto res = DirectX::XMStoreFloat4(DirectX::XMVectorLerp(x1, x2, u));
    auto y1 = lerp(res.x, res.y, v);
    auto y2 = lerp(res.z, res.w, v);
    return lerp(y1, y2, w) + 1 / 2;
}


